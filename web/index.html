<!DOCTYPE html>
<html>

<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <!-- iOS meta tags & icons -->
  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="DipGuide">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://dipreport.com/">
  <meta property="og:title" content="Dip Report — Sea Swimming Conditions Ireland">
  <meta property="og:description" content="Real-time coastal forecasts, tide data, wave heights and the Roughness Index for open water swimmers in Ireland.">
  <meta property="og:image" content="https://dipreport.com/icons/Icon-512.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://dipreport.com/">
  <meta property="twitter:title" content="Dip Report — Sea Swimming Conditions Ireland">
  <meta property="twitter:description" content="Real-time coastal forecasts, tide data, wave heights and the Roughness Index for open water swimmers in Ireland.">
  <meta property="twitter:image" content="https://dipreport.com/icons/Icon-512.png">

  <title>Dip Report — Sea Swimming Conditions Ireland</title>
  <meta name="msvalidate.01" content="0FE9E4CC4C70DD8C41F92A1C2CFDF8F0" />
  <link rel="manifest" href="manifest.json">
</head>

<body style="background-color:#0f172a;margin:0;">

  <!-- Loading spinner — visible immediately, removed once Flutter mounts -->
  <div id="loading" style="
    position:fixed;inset:0;
    background:#0f172a;
    display:flex;flex-direction:column;
    align-items:center;justify-content:center;
    z-index:9999;
  ">
    <svg width="48" height="48" viewBox="0 0 48 48" fill="none" style="margin-bottom:20px">
      <path d="M24 4 C24 4 40 14 40 28 C40 37 32.8 44 24 44 C15.2 44 8 37 8 28 C8 14 24 4 24 4Z"
        fill="none" stroke="#3B82F6" stroke-width="2.5" stroke-linecap="round"/>
    </svg>
    <div style="
      width:36px;height:36px;
      border:3px solid #1e293b;
      border-top-color:#3B82F6;
      border-radius:50%;
      animation:spin 0.8s linear infinite;
    "></div>
    <p style="color:#64748b;font-family:sans-serif;font-size:13px;margin-top:16px;letter-spacing:0.05em;">
      Loading…
    </p>
  </div>
  <style>
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>

  <script src="flutter_bootstrap.js" async></script>
  <script>
    // Remove the loading overlay once Flutter paints its first frame
    (function() {
      const remove = () => {
        const el = document.getElementById('loading');
        if (el) {
          el.style.transition = 'opacity 0.3s';
          el.style.opacity = '0';
          setTimeout(() => el.remove(), 300);
        }
      };
      // Flutter adds a <flt-glass-pane> or <flutter-view> when it mounts
      const observer = new MutationObserver(() => {
        if (document.querySelector('flt-glass-pane,flutter-view')) {
          observer.disconnect();
          remove();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
      // Hard fallback — remove after 12s no matter what
      setTimeout(remove, 12000);
    })();
  </script>
  <script>
    // ── Service Worker + Push Notifications ──────────────────────────────────

    const VAPID_PUBLIC_KEY = window._VAPID_PUBLIC_KEY || '';

    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const rawData = atob(base64);
      return Uint8Array.from([...rawData].map(c => c.charCodeAt(0)));
    }

    let _swRegistration = null;

    async function registerServiceWorker() {
      if (!('serviceWorker' in navigator)) return null;
      try {
        _swRegistration = await navigator.serviceWorker.register('/sw.js');
        console.log('DipGuide: SW registered');
        return _swRegistration;
      } catch (e) {
        console.error('DipGuide: SW registration failed', e);
        return null;
      }
    }

    window.requestPushPermission = async function () {
      if (!('Notification' in window)) return 'unsupported';
      const permission = await Notification.requestPermission();
      return permission; // 'granted' | 'denied' | 'default'
    };

    window.getPushPermission = function () {
      if (!('Notification' in window)) return 'unsupported';
      return Notification.permission;
    };

    window.subscribeToPush = async function (vapidKey) {
      const key = vapidKey || VAPID_PUBLIC_KEY;
      if (!key) return JSON.stringify({ error: 'no_vapid_key' });
      try {
        const reg = _swRegistration || await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(key),
        });
        return JSON.stringify(sub.toJSON());
      } catch (e) {
        return JSON.stringify({ error: e.message });
      }
    };

    window.unsubscribeFromPush = async function () {
      try {
        const reg = _swRegistration || await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.getSubscription();
        if (sub) await sub.unsubscribe();
        return 'ok';
      } catch (e) {
        return 'error';
      }
    };

    window.getPushSubscription = async function () {
      try {
        const reg = _swRegistration || await navigator.serviceWorker.ready;
        const sub = await reg.pushManager.getSubscription();
        return sub ? JSON.stringify(sub.toJSON()) : null;
      } catch (e) {
        return null;
      }
    };

    registerServiceWorker();

    if ('serviceWorker' in navigator) {
      // One-time migration: unregister the old Flutter SW and wipe its caches.
      // We only do this once per browser session to avoid reload loops.
      if (!sessionStorage.getItem('sw_migrated')) {
        sessionStorage.setItem('sw_migrated', '1');
        navigator.serviceWorker.getRegistrations().then(registrations => {
          let unregistered = false;
          for (const reg of registrations) {
            const url = (reg.active || reg.installing || reg.waiting || {}).scriptURL || '';
            if (url.includes('flutter_service_worker')) {
              reg.unregister();
              unregistered = true;
              console.log('DipReport: unregistered old Flutter SW');
            }
          }
          if (unregistered) {
            // Wipe stale Flutter caches only when we found and removed the old SW
            caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
          }
        });
      }

      // No controllerchange reload — it causes infinite loops.
      // Entry points are always fetched from network so new deploys
      // are picked up automatically without needing a forced reload.
    }

    // ── PWA Install Prompt ────────────────────────────────────────────────────

    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      console.log('DipGuide: PWA beforeinstallprompt fired');
      if (window.onPWAInstallable) {
        window.onPWAInstallable();
      }
    });

    window.addEventListener('appinstalled', (evt) => {
      console.log('DipGuide: PWA was installed');
      deferredPrompt = null;
      if (window.onPWAInstalled) {
        window.onPWAInstalled();
      }
    });

    window.isPWAInstallable = function () {
      const isInstallable = deferredPrompt !== undefined;
      console.log('DipGuide: isPWAInstallable called, returning', isInstallable);
      return isInstallable;
    };

    window.installPWA = async function () {
      if (!deferredPrompt) return 'not_installable';
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      deferredPrompt = null;
      return outcome;
    };
  </script>
</body>

</html>